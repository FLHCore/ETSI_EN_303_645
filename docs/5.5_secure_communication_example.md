# 5.5 安全地通訊 (Secure Communication) 範例

本文件提供一個基於 ETSI EN 303 645 標準 5.5 節「安全地通訊」的 Python 程式碼範例。

此範例展示了一個智慧家庭 IoT 中樞 (Hub) 如何使用 TLS (Transport Layer Security) 和客戶端證書認證，與雲端 MQTT 服務進行端到端的加密通訊。

## 場景

- **IoT 中樞 (Hub)**：部署在家中的設備，負責收集感測器資料 (例如：溫度)，並將其安全地發送到雲端。同時，它也訂閱雲端的指令 (例如：開/關燈)。
- **雲端服務 (Cloud Service)**：在雲端運行的後端應用程式，負責接收來自中樞的資料，並向中樞發送指令。
- **MQTT Broker**：一個支援 TLS 客戶端證書認證的訊息代理伺服器。基於安全考量，中樞和雲端服務都必須提供有效的證書才能連線。

---

## 準備工作

### 1. 安裝 Paho MQTT 函式庫

這是 Python 中最受歡迎的 MQTT 客戶端函式庫，它支援 TLS。

```bash
pip install paho-mqtt
```

### 2. 建立安全憑證 (Certificates)

為了實現安全的 TLS 通訊和雙向認證，我們需要建立自己的憑證頒發機構 (CA) 和客戶端證書。這符合 **5.5-2** 使用經審查的實作 (OpenSSL) 和 **5.5-8** 安全管理金鑰的要求。

**注意**：在生產環境中，應使用受信任的商業 CA 或安全的內部 PKI 設施。

使用 OpenSSL 執行以下指令來產生測試憑證：

```bash
# --- 1. 建立自己的憑證頒發機構 (CA) ---
# 產生 CA 的私鑰
openssl genrsa -out ca.key 2048
# 產生 CA 的根證書 (Root Certificate)
openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -subj "/C=TW/ST=Taiwan/L=Taipei/O=MyHomeIoT/CN=MyHomeIoT.CA"

# --- 2. 建立 MQTT Broker/Server 的證書 (由我們的 CA 簽署) ---
# 產生伺服器私鑰
openssl genrsa -out server.key 2048
# 產生證書簽署請求 (CSR)
openssl req -new -key server.key -out server.csr -subj "/C=TW/ST=Taiwan/L=Taipei/O=MyHomeIoT/CN=localhost"
# 使用我們的 CA 簽署伺服器證書
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365

# --- 3. 建立 IoT 中樞 (Hub) 的客戶端證書 ---
# 產生客戶端私鑰
openssl genrsa -out hub_client.key 2048
# 產生 CSR
openssl req -new -key hub_client.key -out hub_client.csr -subj "/C=TW/ST=Taiwan/L=Taipei/O=MyHomeIoT/CN=iot-hub-001"
# 使用我們的 CA 簽署客戶端證書
openssl x509 -req -in hub_client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out hub_client.crt -days 365

# --- 4. 建立雲端服務 (Cloud Service) 的客戶端證書 ---
# 產生客戶端私鑰
openssl genrsa -out cloud_client.key 2048
# 產生 CSR
openssl req -new -key cloud_client.key -out cloud_client.csr -subj "/C=TW/ST=Taiwan/L=Taipei/O=MyHomeIoT/CN=cloud-service-backend"
# 使用我們的 CA 簽署客戶端證書
openssl x509 -req -in cloud_client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out cloud_client.crt -days 365
```

### 3. 設定 MQTT Broker

您需要一個支援 TLS 和證書認證的 MQTT Broker，例如 [Mosquitto](https://mosquitto.org/)。
在 Mosquitto 的設定檔 (`mosquitto.conf`) 中，您需要加入以下設定：

```ini
# 監聽 8883 port (MQTT over TLS)
listener 8883

# CA 證書路徑
cafile /path/to/your/certs/ca.crt

# Broker 的伺服器證書和私鑰
certfile /path/to/your/certs/server.crt
keyfile /path/to/your/certs/server.key

# 強制要求客戶端提供證書進行認證
require_certificate true

# 建議指定 TLS 版本，實現加密敏捷性 (Crypto-agility)
tls_version tlsv1.2
```

---

## Python 程式碼範例

### 1. `iot_hub_device.py` (智慧家庭中樞)

```python
import paho.mqtt.client as mqtt
import ssl
import time
import json

# --- 設定 ---
BROKER_ADDRESS = "localhost"  # 您的 MQTT Broker 地址
BROKER_PORT = 8883
DEVICE_ID = "iot-hub-001"

# --- 憑證路徑 (請替換成您自己的路徑) ---
# 這是實現 5.5-4 (身分驗證) 和 5.5-7 (保護關鍵參數機密性) 的關鍵
CA_CERT_PATH = "/path/to/your/certs/ca.crt"
CLIENT_CERT_PATH = "/path/to/your/certs/hub_client.crt"
CLIENT_KEY_PATH = "/path/to/your/certs/hub_client.key"

# --- 主題 (Topics) ---
TOPIC_DATA = f"devices/{DEVICE_ID}/data"
TOPIC_COMMAND = f"devices/{DEVICE_ID}/command"

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("成功連線到 MQTT Broker!")
        client.subscribe(TOPIC_COMMAND)
        print(f"已訂閱主題: {TOPIC_COMMAND}")
    else:
        print(f"連線失敗，返回碼: {rc}")

def on_message(client, userdata, msg):
    print(f"收到來自主題 '{msg.topic}' 的指令: {msg.payload.decode()}")
    # 在這裡處理收到的指令，例如控制家裡的燈光

def setup_tls_context():
    """
    設定 TLS Context，這符合 5.5-1 (使用最佳實踐加密) 和 5.5-3 (加密敏捷性)
    """
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=CA_CERT_PATH)
    # 載入客戶端證書和私鑰進行身分驗證
    context.load_cert_chain(certfile=CLIENT_CERT_PATH, keyfile=CLIENT_KEY_PATH)
    # 允許更換加密演算法，例如限制 TLS 版本
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    return context

def main():
    client = mqtt.Client(client_id=DEVICE_ID)
    client.on_connect = on_connect
    client.on_message = on_message

    # 設定 TLS，所有通訊都將被加密
    tls_context = setup_tls_context()
    client.tls_set_context(tls_context)

    print("正在連線到 MQTT Broker...")
    client.connect(BROKER_ADDRESS, BROKER_PORT)

    client.loop_start()

    # 模擬每 10 秒發送一次溫度資料
    try:
        while True:
            temperature = 25.5 + (time.time() % 5) # 模擬溫度變化
            payload = json.dumps({"sensor": "temperature", "value": temperature})
            
            # 發布的資料也透過 TLS 加密，符合 5.5-6
            client.publish(TOPIC_DATA, payload)
            print(f"發布資料: {payload}")
            time.sleep(10)
    except KeyboardInterrupt:
        print("程式結束")
        client.loop_stop()
        client.disconnect()

if __name__ == "__main__":
    main()
```

### 2. `cloud_service.py` (雲端後端服務)

```python
import paho.mqtt.client as mqtt
import ssl
import time

# --- 設定 ---
BROKER_ADDRESS = "localhost"
BROKER_PORT = 8883
SERVICE_ID = "cloud-service-backend"
TARGET_DEVICE_ID = "iot-hub-001" # 要控制的目標設備

# --- 憑證路徑 (請替換成您自己的路徑) ---
CA_CERT_PATH = "/path/to/your/certs/ca.crt"
CLIENT_CERT_PATH = "/path/to/your/certs/cloud_client.crt"
CLIENT_KEY_PATH = "/path/to/your/certs/cloud_client.key"

# --- 主題 (Topics) ---
TOPIC_DATA = f"devices/{TARGET_DEVICE_ID}/data"
TOPIC_COMMAND = f"devices/{TARGET_DEVICE_ID}/command"

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("雲端服務成功連線到 MQTT Broker!")
        client.subscribe(TOPIC_DATA)
        print(f"已訂閱主題: {TOPIC_DATA}")
    else:
        print(f"連線失敗，返回碼: {rc}")

def on_message(client, userdata, msg):
    print(f"收到來自 '{msg.topic}' 的資料: {msg.payload.decode()}")
    # 在這裡處理收到的資料，例如存入資料庫或進行分析

def setup_tls_context():
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=CA_CERT_PATH)
    context.load_cert_chain(certfile=CLIENT_CERT_PATH, keyfile=CLIENT_KEY_PATH)
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    return context

def main():
    client = mqtt.Client(client_id=SERVICE_ID)
    client.on_connect = on_connect
    client.on_message = on_message

    tls_context = setup_tls_context()
    client.tls_set_context(tls_context)

    print("雲端服務正在連線到 MQTT Broker...")
    client.connect(BROKER_ADDRESS, BROKER_PORT)

    client.loop_start()

    # 模擬每 30 秒發送一次開燈指令
    try:
        while True:
            time.sleep(30)
            command = "TURN_LIGHT_ON"
            
            # 發布的指令也透過 TLS 加密，符合 5.5-5 (安全相關變更需認證)
            client.publish(TOPIC_COMMAND, command)
            print(f"發送指令: {command}")
            
    except KeyboardInterrupt:
        print("程式結束")
        client.loop_stop()
        client.disconnect()

if __name__ == "__main__":
    main()
```

---

## 範例如何符合 ETSI EN 303 645 (5.5)

- **5.5-1 (使用最佳實踐加密)**: 範例使用 TLS v1.2，這是目前公認的網路通訊加密標準。
- **5.5-2 (使用經審查的實作)**: 範例使用了 Python 內建的 `ssl` 模組和廣泛使用的 `paho-mqtt` 函式庫，這些都是經過社群大量審查和使用的成熟方案。
- **5.5-3 (加密敏捷性)**: 在 `setup_tls_context` 函式中，可以透過 `context.minimum_version` 等參數調整 TLS 版本或密碼套件 (Cipher Suite)，這使得當未來發現某個加密演算法不安全時，可以輕鬆地更換或禁用它。
- **5.5-4 (網路介面存取需認證)**: MQTT Broker 被設定為 `require_certificate = true`，這意味著任何客戶端 (無論是 IoT 中樞還是雲端服務) 都必須提供由我們 CA 簽署的有效證書才能連線。沒有證書的設備將無法存取任何功能。
- **5.5-5 (安全相關變更需認證)**: 由於所有通訊都建立在經過認證的 TLS 連線之上，因此發送任何指令 (例如 `TURN_LIGHT_ON`) 都隱含了發送者已經過身分驗證。
- **5.5-6 & 5.5-7 (傳輸中加密關鍵參數)**: 整個 MQTT 通訊，包括設備 ID、主題、酬載 (payload)，以及用於連線的客戶端證書本身，都在 TLS 通道內被加密傳輸，確保了其機密性和完整性。
- **5.5-8 (安全管理關鍵參數)**: 範例透過使用 OpenSSL 產生和管理私鑰與證書，展示了金鑰管理流程的基礎。在真實世界中，這會是一個更複雜、更安全的流程 (例如使用硬體安全模組 HSM)。
