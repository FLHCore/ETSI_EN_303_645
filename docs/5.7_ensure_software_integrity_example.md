# 5.7 Ensure software integrity (確保軟體完整性) 系統設計範例 (基於 Raspberry Pi CM5)

本文件旨在針對 ETSI EN 303 645 的「5.7 確保軟體完整性」條款，提出一個基於 Raspberry Pi Compute Module 5 (CM5) 硬體的系統設計與實作範例。

## 核心原則

軟體完整性確保裝置上運行的程式碼是經授權且未被竄改的。這主要透過兩大機制來實現：

1.  **安全啟動 (Secure Boot)**：從硬體層面驗證啟動過程中的每一個軟體元件（Bootloader, Kernel）的真實性。
2.  **安全的軟體更新 (Secure Software Updates)**：確保從下載到安裝的整個更新過程都是安全的，更新包本身必須經過簽章驗證。

## 系統架構設計

我們假設的 Raspberry Pi CM5 支援硬體安全啟動。整體設計如下：

**設計圖文字說明:**

1.  **硬體信任根 (Hardware Root of Trust)**: CM5 的 SoC 包含一個 Boot ROM，其中含有製造商的公鑰。這是信任鏈的起點。
2.  **安全啟動鏈 (Secure Boot Chain)**:
    *   Boot ROM 驗證 Bootloader 的簽章。
    *   Bootloader 驗證 Kernel 的簽章。
    *   Kernel 啟動一個唯讀的根檔案系統 (read-only root filesystem)。
3.  **唯讀根檔案系統**: 系統的主要部分（包括作業系統和應用程式）都儲存在一個唯讀的分割區，防止在運行時被惡意修改。只有特定的資料分割區 (`/data`, `/var/log`) 是可寫的。
4.  **安全的更新流程**:
    *   **開發/建置伺服器 (Build Server)**: 開發人員完成新的軟體版本後，在一個安全的環境中對其進行打包和數位簽章，產生更新包 (`update.pkg`) 和簽章檔 (`update.sig`)。
    *   **更新伺服器 (Update Server)**: 存放更新包、簽章檔以及一個描述更新資訊的 `manifest.json` 檔案。此伺服器必須使用 HTTPS。
    *   **裝置端更新代理 (Device Update Agent)**: 在 Pi 上運行的 Python 服務，負責定期檢查更新、下載、驗證並安裝。

---

## 安全軟體更新的實作範例

這是整個流程中可以透過應用層程式碼來實現的關鍵部分。

### 1. 伺服器端：建立與簽署更新包

此步驟在安全的後端環境中執行。

**a. 產生 GPG 金鑰對** (僅需執行一次)
```bash
# 產生一個新的金鑰對，用於簽署軟體
gpg --full-generate-key
```
這會產生一個公鑰和一個私鑰。私鑰必須被嚴格保護。公鑰則需要預先安裝到所有 IoT 裝置的唯讀分割區中。

**b. 簽署更新包**
假設我們有一個軟體更新包 `app_v2.tar.gz`。
```bash
# 使用私鑰為更新包產生一個分離的簽章檔
gpg --output app_v2.sig --detach-sig app_v2.tar.gz
```

**c. 建立 Manifest 檔案**
更新伺服器上需要有一個 `manifest.json` 檔案，讓裝置知道有新版本。
```json
{
  "version": "2.0.0",
  "description": "新增溫度校正功能並修復安全漏洞。",
  "package_url": "https://your-secure-update-server.com/updates/app_v2.tar.gz",
  "signature_url": "https://your-secure-update-server.com/updates/app_v2.sig",
  "release_date": "2025-11-07"
}
```

### 2. 裝置端：更新代理 (Python 範例)

這個 Python 腳本 (`update_agent.py`) 在 Raspberry Pi 上作為一個服務運行。

**事前準備 (在裝置上):**

1.  **安裝 `python-gnupg`**:
    ```bash
    pip install python-gnupg
    ```
2.  **匯入製造商的公鑰**:
    將之前產生的公鑰檔案 (`manufacturer_pub.asc`) 存放在裝置的唯讀區域 (例如 `/etc/keys/`)，然後匯入 GPG keyring。
    ```bash
    gpg --import /etc/keys/manufacturer_pub.asc
    ```

**Python 程式碼 (`update_agent.py`):**

```python
# update_agent.py
import os
import requests
import json
import gnupg
import subprocess

# --- 設定 ---
CURRENT_VERSION = "1.0.0"  # 這個版本號應該從一個受保護的檔案中讀取
MANIFEST_URL = "https://your-secure-update-server.com/updates/manifest.json"
DOWNLOAD_DIR = "/tmp/updates"
GPG_HOME = "/home/pi/.gnupg" # GPG keyring 的位置

def get_current_version():
    """從一個受保護的檔案中讀取當前版本。"""
    try:
        with open("/etc/app_version", "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return "0.0.0"

def check_for_updates():
    """從伺服器檢查是否有新版本。"""
    print("Checking for updates...")
    try:
        response = requests.get(MANIFEST_URL, timeout=15)
        response.raise_for_status()  # 確保請求成功
        
        manifest = response.json()
        latest_version = manifest.get("version")
        
        current_version = get_current_version()
        print(f"Current version: {current_version}, Latest version: {latest_version}")

        if latest_version and latest_version > current_version:
            print("New version available. Starting download...")
            download_and_verify(manifest)
        else:
            print("Software is up to date.")

    except requests.exceptions.RequestException as e:
        print(f"Error checking for updates: {e}")
    except json.JSONDecodeError:
        print("Failed to parse manifest file.")

def download_and_verify(manifest):
    """下載更新包和簽章，並進行驗證。"""
    package_url = manifest.get("package_url")
    signature_url = manifest.get("signature_url")

    if not package_url or not signature_url:
        print("Manifest is missing URLs.")
        return

    try:
        # 建立下載目錄
        os.makedirs(DOWNLOAD_DIR, exist_ok=True)
        
        package_path = os.path.join(DOWNLOAD_DIR, "update_package")
        signature_path = os.path.join(DOWNLOAD_DIR, "update_signature")

        # 下載更新包
        print(f"Downloading package from {package_url}...")
        r_pkg = requests.get(package_url, stream=True)
        r_pkg.raise_for_status()
        with open(package_path, 'wb') as f:
            for chunk in r_pkg.iter_content(chunk_size=8192):
                f.write(chunk)

        # 下載簽章
        print(f"Downloading signature from {signature_url}...")
        r_sig = requests.get(signature_url)
        r_sig.raise_for_status()
        with open(signature_path, 'wb') as f:
            f.write(r_sig.content)

        # --- 核心步驟：驗證簽章 ---
        print("Verifying software integrity...")
        gpg = gnupg.GPG(gnupghome=GPG_HOME)
        
        with open(signature_path, 'rb') as f:
            verification_result = gpg.verify_file(f, package_path)

        if verification_result and verification_result.valid:
            print("Signature is VALID. Proceeding with installation.")
            # 在這裡觸發安裝腳本
            # install_update(package_path)
        else:
            print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            print("!! CRITICAL: SIGNATURE VERIFICATION FAILED !!")
            print("!! Update package may be compromised. Aborting. !!")
            print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            # 清理不安全的檔案
            cleanup()

    except Exception as e:
        print(f"An error occurred during download or verification: {e}")
        cleanup()

def cleanup():
    """清理下載的檔案。"""
    if os.path.exists(DOWNLOAD_DIR):
        import shutil
        shutil.rmtree(DOWNLOAD_DIR)
    print("Cleaned up temporary files.")

if __name__ == "__main__":
    check_for_updates()

```

## 總結

這個設計透過以下方式確保了軟體完整性：

1.  **信任根**：利用 Raspberry Pi CM5 的硬體安全啟動功能，建立一個從硬體到核心的信任鏈。
2.  **防竄改**：將根檔案系統設為唯讀，防止惡意軟體在運行時修改系統檔案或應用程式。
3.  **端到端的更新安全**：
    *   所有通訊均使用 HTTPS 加密。
    *   所有軟體更新都經過開發者私鑰的數位簽章。
    *   裝置端使用預先安裝的公鑰對簽章進行強制驗證，只有驗證通過的更新才會被安裝。

這個多層次的防禦策略，有效地滿足了 ETSI EN 303 645 對於軟體完整性的要求，大大降低了裝置被惡意軟體入侵的風險。
