## 5.3 – 保持軟體更新 (KEEP SOFTWARE UPDATED)

### 條款 7.3-1 (Provision 7.3-1)

製造商或軟體提供商的公鑰 (public verification key) 必須預先安裝在家庭閘道器 (HG) 上。

#### 最低要求 (Minimum Requirements)

* 製造商或軟體提供商的公鑰必須預先安裝在 HG 上的一個**能確保該公鑰完整性 (integrity)** 的位置。
    * 關於公鑰儲存位置的範例包括但不限於：
        * **唯讀記憶體 (Read-only memory)**
        * **安全元件 (Secure Element)**

#### 佐證證據 (Supporting Evidence)

* 開發商應提供證據（例如：截圖、產品文件等），顯示製造商或軟體提供商的公鑰是預先安裝在 HG 的何處。

#### 評估 (Assessment)

* 評估人員將檢查製造商或軟體提供商的公鑰是否預先安裝在 HG 上的一個能確保該公鑰完整性的位置。

---

### 開發者深度導讀 (針對 Gateway / App / Cloud 開發商)

#### 本章節核心要求與意涵

本條款探討的是**信任根 (Root of Trust)** 的儲存安全。為了驗證韌體更新的合法性（後續條款會要求數位簽章），設備上必須存有一把「公鑰」來解密或驗證簽章。

如果這把公鑰隨便放在可讀寫的檔案系統（如 `/etc/config/`）中，駭客只要取得 Root 權限，就能換成自己的公鑰，進而簽署惡意韌體讓設備安裝。因此，本條款的核心在於**「公鑰本身的防竄改 (Tamper Resistance)」**。

#### 具體落地實現方案建議

* **硬體層級的解決方案（推薦）**：
    * **eFuse / OTP (One-Time Programmable)**：現代 SoC (如 MediaTek, Qualcomm, Realtek) 通常具備 eFuse 區域。將公鑰的 Hash (或公鑰本身) 燒錄進 eFuse，這是最標準的作法。
    * **Secure Element (SE) / TPM**：若硬體成本允許，將金鑰存放在獨立的安全晶片中。
* **軟體層級的解決方案（若硬體不支援）**：
    * **唯讀分割區 (Read-Only Partition)**：將公鑰編譯進 Bootloader 或 Kernel 所在的 Raw Partition，並將該 Partition 掛載為 Read-Only。
    * **程式碼內嵌**：在編譯階段將公鑰宣告為 `const` 變數，使其位於 `.rodata` 區段，並隨韌體映像檔燒錄。但這前提是 Bootloader 本身必須有 Secure Boot 保護，否則替換整個 Image 依然無效。

* **證據收集策略**：
    * **Datasheet 與記憶體映射圖 (Memory Map)**：提供 SoC 的規格書，圈出 "Security Engine" 或 "OTP Memory" 的章節，證明該區域是防寫的。
    * **程式碼截圖**：截取 Bootloader (如 U-Boot) 中讀取公鑰的程式碼片段，證明它是從特定受保護位址讀取，而非從可寫入的檔案系統讀取。
    * **操作示範**：在 Console 下嘗試對儲存公鑰的記憶體位址或檔案進行 `rm` 或 `write` 操作，截取 "Operation not permitted" 或 "Read-only file system" 的錯誤訊息。

* **測試與驗證**：
    * **破壞性測試**：QA 人員應嘗試透過 Root Shell 替換公鑰檔案。如果成功替換且重開機後新公鑰生效，則此項目**不合格**。

---
[回到 5.3 – 保持軟體更新 (KEEP SOFTWARE UPDATED)](./5.3-keep-software-updated.md)
